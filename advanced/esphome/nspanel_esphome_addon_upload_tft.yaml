#####################################################################################################
##### NSPANEL ESPHOME created by Blackymas - https://github.com/Blackymas/NSPanel_HA_Blueprint  #####
##### TFT Upload engine                                                                         #####
##### PLEASE only make changes if it is necessary and also the required knowledge is available. #####
##### For normal use with the Blueprint, no changes are necessary.                              #####
#####################################################################################################
##### ATTENTION: This will add advanced elements to the core system and requires the core part. #####
#####################################################################################################
---
substitutions:
  ################## Defaults ##################
  # Just in case user forgets to set something #
  nextion_update_url: "https://raw.githubusercontent.com/Blackymas/NSPanel_HA_Blueprint/main/nspanel_eu.tft"
  nextion_update_base_url: "https://raw.githubusercontent.com/Blackymas/NSPanel_HA_Blueprint/"
  ##############################################

  ##### DON'T CHANGE THIS #####
  upload_tft_chunk_size_max: "32768"
  upload_tft_baud_rate: "921600"
  #############################

api:
  on_client_connected:
    - script.execute: report_settings

  services:
    ##### SERVICE TO UPDATE THE TFT FILE from URL #####
    ##### It will use the default url if url is empty or "default"
    - service: upload_tft_url
      variables:
        url: string
      then:
        - lambda: |-
            static const char *const TAG = "addon_upload_tft.service.upload_tft_url";
            ESP_LOGVV(TAG, "Starting...");

            std::string clean_url = url;
            // Convert to lowercase
            std::transform(clean_url.begin(), clean_url.end(), clean_url.begin(),
                          [](unsigned char c){ return std::tolower(c); });
            // Trim trailing spaces
            auto endPos = clean_url.find_last_not_of(" \t");
            if (std::string::npos != endPos) {
              clean_url = clean_url.substr(0, endPos + 1);
            }

            if (clean_url.empty() or clean_url == "default") url = id(tft_url);
            upload_tft->execute(url.c_str());

button:
  ##### UPDATE TFT DISPLAY #####
  - id: tft_update
    name: ${name} Update TFT display
    platform: template
    icon: mdi:file-sync
    entity_category: config
    on_press:
      - lambda: |-
          static const char *const TAG = "addon_upload_tft.button.tft_update.on_press";
          ESP_LOGD(TAG, "Update TFT display button pressed");
          upload_tft->execute(id(tft_url).c_str());

display:
  - id: !extend disp1
    tft_url: ${nextion_update_url}
    exit_reparse_on_start: true

esphome:
  on_boot:
    - priority: 601.0
      then:
        - lambda: |-
            // Hide TFT file selectors when using arduino
            #ifdef ARDUINO
            tft_file_branch->set_internal(true);
            tft_file_model->set_internal(true);
            #elif defined(ESP_PLATFORM)
            tft_file_branch->set_internal(false);
            tft_file_model->set_internal(false);
            #endif

globals:
  - id: baud_rate_original
    type: uint
    restore_value: false
    initial_value: '115200'

  - id: baud_rate_target
    type: uint
    restore_value: false
    initial_value: ${upload_tft_baud_rate}

  - id: tft_branch
    type: uint
    restore_value: true
    initial_value: '0'

  - id: tft_is_valid
    type: bool
    restore_value: false
    initial_value: 'false'

  - id: tft_model
    type: uint
    restore_value: true
    initial_value: '0'

  - id: tft_upload_attempt
    type: uint
    restore_value: false
    initial_value: '0'

  - id: tft_url
    type: std::string
    restore_value: false
    initial_value: '"${nextion_update_url}"'

script:
  - id: exit_reparse_v414
    mode: restart
    then:
      - logger.log: "Exit reparse"
      - uart.write:
          id: tf_uart
          data: "DRAKJHSUYDGBNCJHGJKSHBDN"
      - uart.write:
          id: tf_uart
          data: [0xFF, 0xFF, 0xFF]

  - id: nextion_uart_command
    mode: queued
    parameters:
      command: string
    then:
      - lambda: |-
          static const char *const TAG = "addon_upload_tft.script.nextion_uart_command";
          if (disp1->is_setup()) {
            ESP_LOGD(TAG, "Sending `%s` directly to Nextion", command.c_str());
            disp1->send_command_printf(command.c_str());
          } else {
            ESP_LOGD(TAG, "Sending `%s` directly to UART", command.c_str());
            tf_uart->write_str(command.c_str());
            const uint8_t to_send[3] = {0xFF, 0xFF, 0xFF};
            tf_uart->write_array(to_send, sizeof(to_send));
          }
          App.feed_wdt();

  - id: nextion_upload
    mode: single
    then:
      - lambda: |-
          static const char *const TAG = "addon_upload_tft.script.nextion_upload";
          ESP_LOGD(TAG, "Waiting for empty UART and Nextion queues");
      - wait_until:
          condition:
            - lambda: !lambda return (disp1->queue_size()<=0);
            - lambda: !lambda return (tf_uart->available()<=0);
          timeout: 10s
      - delay: 2s
      - lambda: |-
          static const char *const TAG = "addon_upload_tft.script.nextion_upload";
          ESP_LOGD(TAG, "Starting TFT upload...");
          if (disp1->upload_tft()) App.safe_reboot();

  - id: open_upload_dialog
    mode: restart
    then:
      - lambda: |-
          static const char *const TAG = "addon_upload_tft.script.open_upload_dialog";
          ESP_LOGD(TAG, "Showing upload dialog page");
          disp1->goto_page("confirm");
          disp1->hide_component("bt_close");
          disp1->hide_component("bt_accept");
          disp1->hide_component("bt_clear");
          disp1->hide_component("bt_close");
          #ifdef ARDUINO
          disp1->set_component_text_printf("confirm.title", "Upload TFT\\rArduino");
          #elif defined(ESP_PLATFORM)
          disp1->set_component_text_printf("confirm.title", "Upload TFT\\rESP-IDF");
          #endif
          page_id->update();

  - id: report_settings
    mode: restart
    then:
      - delay: 15s
      - lambda: |-
          static const char *const TAG = "addon_upload_tft.script.report_settings";
          ESP_LOGI(TAG, "TFT URL: %s", id(tft_url).c_str());
          ESP_LOGI(TAG, "Substitutions:");
          ESP_LOGI(TAG, "  nextion_update_url:        ${nextion_update_url}");
          ESP_LOGI(TAG, "  nextion_update_base_url:   ${nextion_update_base_url}");
          ESP_LOGI(TAG, "  upload_tft_chunk_size_max: ${upload_tft_chunk_size_max}");
          ESP_LOGI(TAG, "  upload_tft_baud_rate:      ${upload_tft_baud_rate}");

  - id: report_upload_progress
    mode: restart
    parameters:
      message: string
    then:
      - lambda: |-
          static const char *const TAG = "addon_upload_tft.script.report_upload_progress";
          ESP_LOGD(TAG, "%s", message.c_str());
          if (id(tft_is_valid)) {
            if (page_id->state != 26) {
              open_upload_dialog->execute();
            }
            display_wrapped_text->execute("confirm.body", message.c_str(), 18);
            disp1->set_backlight_brightness(1);
            App.feed_wdt();
          }

  - id: !extend restore_settings
    mode: restart
    then:
      - lambda: |-
          static const char *const TAG = "addon_upload_tft.script.restore_settings";

          ESP_LOGD(TAG, "Restoring TFT file branch selector to index %u", id(tft_branch));
          auto tft_file_branch_call = id(tft_file_branch).make_call();
          tft_file_branch_call.set_index(id(tft_branch));
          tft_file_branch_call.perform();

          ESP_LOGD(TAG, "Restoring TFT file model selector to index %u", id(tft_model));
          auto tft_file_model_call = id(tft_file_model).make_call();
          tft_file_model_call.set_index(id(tft_model));
          tft_file_model_call.perform();

  - id: set_tft_file
    mode: restart
    then:
      - delay: 2s
      - lambda: |-
          #ifdef ARDUINO
          static const char *const TAG = "addon_upload_tft.script.set_tft_file.arduino";
          #elif defined(ESP_PLATFORM)
          static const char *const TAG = "addon_upload_tft.script.set_tft_file.esp_idf";
          #endif
          std::string branch = tft_file_branch->state;
          std::string model = tft_file_model->state;
          ESP_LOGD(TAG, "TFT URL set:");
          ESP_LOGD(TAG, "  Branch:   %s", branch.c_str());
          ESP_LOGD(TAG, "  Model:    %s", model.c_str());
          if (id(is_restored_settings) and tft_file_branch->active_index().has_value())
            id(tft_branch) = tft_file_branch->active_index().value();
          if (id(is_restored_settings) and tft_file_model->active_index().has_value())
            id(tft_model) = tft_file_model->active_index().value();

          if (id(is_uploading_tft))
            ESP_LOGW(TAG, "  TFT Upload in progress.");
          else {
            #ifdef ARDUINO
            std::string url = "${nextion_update_url}";
            #elif defined(ESP_PLATFORM)
            std::string url;
            std::string file_name;
            if (model == "NSPanel Blank") file_name = "nspanel_blank.tft";
            else if (model == "NSPanel EU") file_name = "nspanel_eu.tft";
            else if (model == "NSPanel US") file_name = "nspanel_us.tft";
            else if (model == "NSPanel US Landscape") file_name = "nspanel_us_land.tft";
            else if (model == "NSPanel EU (CJK languages)") file_name = "advanced/hmi/nspanel_CJK_eu.tft";
            else if (model == "NSPanel US (CJK languages)") file_name = "advanced/hmi/nspanel_CJK_us.tft";
            else if (model == "NSPanel US Landscape (CJK languages)") file_name = "advanced/hmi/nspanel_CJK_us_land.tft";
            if (file_name.empty()) url = "${nextion_update_url}";
            else {
              std::string base_url("${nextion_update_base_url}");
              url = base_url + branch + "/" + file_name;

              // Remove trailing slashes or spaces
              auto endPos = url.find_last_not_of(" /");
              if (std::string::npos != endPos) {
                  url = url.substr(0, endPos + 1);
              }
            }
            #endif

            ESP_LOGD(TAG, "  Full URL: %s", url.c_str());
            id(tft_url) = url;
            disp1->set_tft_url(url.c_str());
          }

  - id: upload_tft  # I've changed this to use ESPHome commands to avoid the parallelism from lambdas
    mode: single
    parameters:
      url: string
    then:
      # Make sure the screen is ON
      - if:
          condition:
            - switch.is_off: screen_power
          then:
            - switch.turn_on: screen_power
            - delay: 5s
      # Wait for recent changes to TFT url
      - script.wait: set_tft_file
      # Then start the upload
      - lambda: |-
          static const char *const TAG = "addon_upload_tft.script.upload_tft";
          ESP_LOGD(TAG, "Starting...");

          id(is_uploading_tft) = true;

          nextion_status->execute();

          uint32_t supported_baud_rates[] = {2400, 4800, 9600, 19200, 31250, 38400, 57600, 115200, 230400, 250000, 256000, 512000, 921600};

          auto is_baud_rate_supported = [supported_baud_rates](uint32_t baud_rate_requested) -> bool {
            size_t size = sizeof(supported_baud_rates) / sizeof(supported_baud_rates[0]);
            for (size_t i = 0; i < size; ++i) {
                if (supported_baud_rates[i] == baud_rate_requested) {
                    return true;
                }
            }
            return false; // Return false if not found
          };

          // The upload process starts here
          ESP_LOGD(TAG, "Starting the upload script");

          // Detect baud rates to be used
          id(baud_rate_original) = tf_uart->get_baud_rate();
          if (!is_baud_rate_supported(id(baud_rate_original))) id(baud_rate_original) = 115200;

          std::string upload_tft_baud_rate_string = "${upload_tft_baud_rate}";
          id(baud_rate_target) = stoi(upload_tft_baud_rate_string);
          if (!is_baud_rate_supported(id(baud_rate_target))) id(baud_rate_target) = id(baud_rate_original);

          ESP_LOGD(TAG, "  Target upload baud rate: %d bps", id(baud_rate_target));
          ESP_LOGD(TAG, "  Current baud rate:       %" PRIu32 " bps", tf_uart->get_baud_rate());
          ESP_LOGD(TAG, "  Valid TFT:               %s", id(tft_is_valid) ? "True" : "False");

          // Upload URL
          ESP_LOGD(TAG, "  Upload URL:              %s", url.c_str());
          #ifdef ARDUINO
          auto startsWith = [](const std::string& str, const std::string& prefix) -> bool {
            if (str.length() < prefix.length()) return false;

            std::string lowerStr = str.substr(0, prefix.length());
            std::transform(lowerStr.begin(), lowerStr.end(), lowerStr.begin(),
                          [](unsigned char c){ return std::tolower(c); });

            std::string lowerPrefix = prefix;
            std::transform(lowerPrefix.begin(), lowerPrefix.end(), lowerPrefix.begin(),
                          [](unsigned char c){ return std::tolower(c); });

            return lowerStr == lowerPrefix;
          };

          if (startsWith(url, "https")) {
            ESP_LOGE(TAG, "HTTPS is not supported by Arduino framework.");
            ESP_LOGE(TAG, "This transfer will most likely fail.");
            ESP_LOGE(TAG, "Please use HTTP instead.");
          }
          #endif
          disp1->set_tft_url(url.c_str());

          nextion_uart_command->execute("bkcmd=3");

      - lambda: if (id(tft_is_valid)) disp1->goto_page("home");
      - delay: 2s
      - script.execute: open_upload_dialog
      - script.wait: open_upload_dialog
      - lambda: page_id->update();
      - wait_until:
          condition:
            - lambda: !lambda return (page_id->state == 26);
          timeout: 2s
      - script.execute:
          id: report_upload_progress
          message: "Set Nextion unavailable for blueprint calls"
      - script.wait: report_upload_progress
      - binary_sensor.template.publish:
          id: nextion_init
          state: false
      - script.execute:
          id: report_upload_progress
          message: "Stopping other scripts"
      - script.wait: report_upload_progress
      - script.execute: stop_all
      - script.wait: stop_all
      - wait_until:
          condition:
            - lambda: !lambda return (!id(tft_is_valid));
          timeout: 1s

      ### Attempt twice with upload engine from v4.1.4 (115200bps) when TFT isn't detected
      # - if:
      #     condition:
      #       - lambda: !lambda return (not id(tft_is_valid));
      #     then:
      #       - script.execute:
      #           id: upload_tft_sequence_attempt_v414
      #           url: !lambda return url.c_str();
      #           baud_rate: 115200
      #       - script.wait: upload_tft_sequence_attempt_v414

      ### Attempt twice at the target baud rate
      - script.execute:
          id: upload_tft_sequence_attempt
          baud_rate: !lambda return id(baud_rate_target);
      - script.wait: upload_tft_sequence_attempt

      ### Attempt twice at the original baud rate
      - script.execute:
          id: upload_tft_sequence_attempt
          baud_rate: !lambda return id(baud_rate_original);
      - script.wait: upload_tft_sequence_attempt

      ### Attempt twice at the Nextion's default baud rate (115200bps)
      - script.execute:
          id: upload_tft_sequence_attempt
          baud_rate: 115200
      - script.wait: upload_tft_sequence_attempt

      ### Attempt twice with upload engine from v4.1.4 (115200bps)
      - script.execute:
          id: upload_tft_sequence_attempt_v414
          url: !lambda return url.c_str();
          baud_rate: 115200
      - script.wait: upload_tft_sequence_attempt_v414

      ### Exit reparse and attempt twice again
      - script.execute:
          id: report_upload_progress
          message: "Exiting reparse mode"
      - script.execute:
          id: upload_tft_sequence_attempt
          baud_rate: 115200
      - script.wait: upload_tft_sequence_attempt

      ### Then attempt twice again at 9600bps
      - script.execute:
          id: upload_tft_sequence_attempt
          baud_rate: 9600
      - script.wait: upload_tft_sequence_attempt

      ### Restart Nextion and attempt twice again at default baud rate (115200bps)
      - script.execute:
          id: report_upload_progress
          message: "Restarting Nextion display"
      - script.wait: report_upload_progress
      - wait_until:
          condition:
            - lambda: !lambda return (!id(tft_is_valid));
          timeout: 3s
      - switch.turn_off: screen_power
      - delay: 2s
      - switch.turn_on: screen_power
      - delay: 5s
      - script.execute:
          id: upload_tft_sequence_attempt
          baud_rate: 115200
      - script.wait: upload_tft_sequence_attempt

      ### All tries failed ###
      - script.execute:
          id: report_upload_progress
          message: "TFT upload failed"
      - script.wait: report_upload_progress
      - wait_until:
          condition:
            - lambda: !lambda return (!id(tft_is_valid));
          timeout: 5s
      - script.execute:
          id: report_upload_progress
          message: "Turn off Nextion and restart ESPHome"
      - script.wait: report_upload_progress
      - wait_until:
          condition:
            - lambda: !lambda return (!id(tft_is_valid));
          timeout: 5s
      - switch.turn_off: screen_power
      - delay: 2s
      # Restart ESPHome
      - lambda: !lambda App.safe_reboot();

      ### This code should never run
      - delay: 2s
      - lambda: |-
          static const char *const TAG = "addon_upload_tft.script.upload_tft";
          ESP_LOGD(TAG, "Finishing...");
          id(is_uploading_tft) = false;
          screen_power->publish_state(true);
          ESP_LOGE(TAG, "TFT upload finished unsuccessfully!");

  - id: upload_tft_sequence_attempt
    mode: single
    parameters:
      baud_rate: uint
    then:
      - script.execute: nextion_status
      - script.wait: nextion_status
      - script.execute:
          id: report_upload_progress
          message: "Setting baud rate"
      - script.wait: report_upload_progress
      - script.execute:
          id: set_baud_rate
          baud_rate: !lambda return baud_rate;
          definitive: false
      - script.wait: set_baud_rate
      - delay: 2s
      # First attempt
      - script.execute: upload_tft_attempt
      - script.wait: upload_tft_attempt
      - delay: 5s
      # Backup attempt
      - script.execute: upload_tft_attempt
      - script.wait: upload_tft_attempt
      - delay: 5s

  - id: upload_tft_sequence_attempt_v414
    mode: single
    parameters:
      url: string
      baud_rate: uint
    then:
      - script.execute: nextion_status
      - script.wait: nextion_status
      - script.execute:
          id: report_upload_progress
          message: "Setting baud rate"
      - script.wait: report_upload_progress
      - script.execute:
          id: set_baud_rate
          baud_rate: !lambda return baud_rate;
          definitive: false
      - script.wait: set_baud_rate
      - delay: 2s
      # Attempt #7
      - script.execute:
          id: upload_tft_v414
          url: !lambda return url.c_str();
      - script.wait: upload_tft_v414
      - delay: 5s
      # Attempt #8
      - script.execute:
          id: upload_tft_v414
          url: !lambda return url.c_str();
      - script.wait: upload_tft_v414
      - delay: 5s

  - id: upload_tft_v414
    mode: single
    parameters:
      url: string
    then:
      - lambda: |-
          static const char *const TAG = "addon_upload_tft.script.upload_tft_v414";
          ESP_LOGD(TAG, "Attempting to upload TFT");
          id(tft_upload_attempt)++;
          char update_msg[128];
          sprintf(update_msg, "Attempt #%d at %" PRIu32 " bps", id(tft_upload_attempt), tf_uart->get_baud_rate());
          report_upload_progress->execute(update_msg);
      - script.wait: report_upload_progress
      - wait_until:
          condition:
            - lambda: !lambda return (!id(tft_is_valid));
          timeout: 1s
      - lambda: |-
          static const char *const TAG = "addon_upload_tft.script.upload_tft_v414";
          ESP_LOGD(TAG, "Starting...");
          std::vector<uint8_t> buffer_;

          bool is_updating_ = false;

          bool upload_first_chunk_sent_ = false;

          int content_length_ = 0;
          int tft_size_ = 0;

          auto delay_seconds_ = [](int seconds) {
            ESP_LOGD(TAG, "Wait %i seconds", seconds);
            for (int i = 0; i < (seconds*4); i++) {
              #ifdef ARDUINO
              delay(250);
              #elif defined(USE_ESP_IDF)
              vTaskDelay(pdMS_TO_TICKS(250));
              #endif
              App.feed_wdt();
            }
          };

          auto set_baud_rate_ = [](int baud_rate) {
            #ifdef USE_ARDUINO
            auto *uart = reinterpret_cast<uart::ESP32ArduinoUARTComponent *>(tf_uart);
            #endif
            #ifdef USE_ESP_IDF
            auto *uart = reinterpret_cast<uart::IDFUARTComponent *>(tf_uart);
            #endif
            uart->set_baud_rate(baud_rate);
            uart->setup();
          };

          auto send_nextion_command = [](const std::string &command) -> bool
            {
              static const char *const TAG = "addon_upload_tft.script.upload_tft.send_nextion_command";
              ESP_LOGD(TAG, "Sending: %s", command.c_str());
              id(tf_uart).write_str(command.c_str());
              const uint8_t to_send[3] = {0xFF, 0xFF, 0xFF};
              id(tf_uart).write_array(to_send, sizeof(to_send));
              return true;
            };

          auto recv_ret_string_ = [](std::string &response, uint32_t timeout, bool recv_flag) -> uint16_t
            {
              static const char *const TAG = "script.upload_tft.recv_ret_string_";
              uint16_t ret;
              uint8_t c = 0;
              uint8_t nr_of_ff_bytes = 0;
              uint64_t start;
              bool exit_flag = false;
              bool ff_flag = false;

              start = millis();

              while ((timeout == 0 && id(tf_uart).available()) || millis() - start <= timeout)
                {
                  if (!id(tf_uart).available())
                    {
                      App.feed_wdt();
                      continue;
                    }

                  id(tf_uart).read_byte(&c);
                  if (c == 0xFF)
                    {
                      nr_of_ff_bytes++;
                    }
                  else
                    {
                      nr_of_ff_bytes = 0;
                      ff_flag = false;
                    }

                  if (nr_of_ff_bytes >= 3)
                    ff_flag = true;

                  response += (char) c;
                  if (recv_flag)
                    {
                      if (response.find(0x05) != std::string::npos)
                        {
                          exit_flag = true;
                        }
                    }
                  App.feed_wdt();
                  delay(2);

                  if (exit_flag || ff_flag)
                    {
                      break;
                    }
                }

              if (ff_flag)
                response = response.substr(0, response.length() - 3); // Remove last 3 0xFF

              ret = response.length();
              return ret;
            };

          auto upload_end_ = [&](bool completed) -> bool
            {
              static const char *const TAG = "script.upload_tft.upload_end_";
              ESP_LOGD(TAG, "Completed: %s", completed ? "True" : "False");
              //ESP_LOGD(TAG, "Restarting Nextion");
              //send_nextion_command("rest");
              #ifdef ARDUINO
              delay(1500);
              #elif defined(ESP_PLATFORM)
              //vTaskDelay(pdMS_TO_TICKS(1500));
              #endif

              is_updating_ = false;
              if (!completed) ESP_LOGD(TAG, "Nextion TFT upload will attempt again");
              return completed;
            };

          #ifdef ARDUINO // arduino # To do: Move to Nextion component on ESPHome
          size_t transfer_buffer_size_ = 0;
          uint8_t *transfer_buffer_{nullptr};
          auto upload_by_chunks_arduino = [&](HTTPClient *http, const std::string &url, int range_start) -> int
            {
              static const char *const TAG = "script.upload_tft.upload_by_chunks_arduino";
              int range_end;

              if (range_start == 0 && transfer_buffer_size_ > 16384) { // Start small at the first run in case of a big skip
                range_end = 16384 - 1;
              } else {
                range_end = range_start + transfer_buffer_size_ - 1;
              }

              if (range_end > tft_size_)
                range_end = tft_size_;

              char range_header[64];
              sprintf(range_header, "bytes=%d-%d", range_start, range_end);

              ESP_LOGD(TAG, "Requesting range: %s", range_header);

              int tries = 1;
              int code;
              bool begin_status;
              while (tries <= 10) {
                begin_status = http->begin(url.c_str());

                ++tries;
                if (!begin_status) {
                  ESP_LOGD(TAG, "Connection failed");
                  delay(1000);
                  continue;
                };

                http->addHeader("Range", range_header);

                code = http->GET();
                if (code == 200 || code == 206) {
                  break;
                }
                ESP_LOGW(TAG, "HTTP Request failed; URL: %s; Error: %s, retries(%d/10)", url.c_str(),
                        HTTPClient::errorToString(code).c_str(), tries);
                http->end();
                delay(1000);
              }

              if (tries > 10) {
                return -1;
              }

              std::string recv_string;
              size_t size;
              int fetched = 0;
              int range = range_end - range_start;
              int write_len;

              // fetch next segment from HTTP stream
              while (fetched < range) {
                size = http->getStreamPtr()->available();
                if (!size) {
                  App.feed_wdt();
                  delay(2);
                  continue;
                }
                int c = http->getStreamPtr()->readBytes(
                    &transfer_buffer_[fetched], ((size > transfer_buffer_size_) ? transfer_buffer_size_ : size));
                fetched += c;
              }
              http->end();
              ESP_LOGD(TAG, "Fetched %d bytes", fetched);

              // upload fetched segments to the display in 4KB chunks
              for (int i = 0; i < range; i += 4096) {
                App.feed_wdt();
                write_len = content_length_ < 4096 ? content_length_ : 4096;
                id(tf_uart).write_array(&transfer_buffer_[i], write_len);
                content_length_ -= write_len;
                ESP_LOGD(TAG, "Uploaded %0.1f %%, remaining %d bytes",
                        100.0 * (tft_size_ - content_length_) / tft_size_,
                        content_length_);

                if (!upload_first_chunk_sent_) {
                  upload_first_chunk_sent_ = true;
                  delay(500);
                }

                recv_ret_string_(recv_string, 5000, true);
                if (recv_string[0] != 0x05) { // 0x05 == "ok"
                  ESP_LOGD(TAG, "recv_string [%s]",
                          format_hex_pretty(reinterpret_cast<const uint8_t *>(recv_string.data()), recv_string.size()).c_str());
                }

                // handle partial upload request
                if (recv_string[0] == 0x08 && recv_string.size() == 5) {
                  uint32_t result = 0;
                  for (int j = 0; j < 4; ++j) {
                    result += static_cast<uint8_t>(recv_string[j + 1]) << (8 * j);
                  }
                  if (result > 0) {
                    ESP_LOGD(TAG, "Nextion reported new range %d", result);
                    content_length_ = tft_size_ - result;
                    return result;
                  }
                }

                recv_string.clear();
              }
              return range_end + 1;
            };
          auto upload_tft_ = [&](const std::string &url, uint32_t update_baud_rate_) -> bool
            {
              static const char *const TAG = "addon_upload_tft.script.upload_tft.upload_tft_arduino";
              ESP_LOGD(TAG, "Nextion TFT upload requested");
              ESP_LOGD(TAG, "  url: %s", url.c_str());
              ESP_LOGD(TAG, "  baud_rate: %" PRIu32, update_baud_rate_);

              if (is_updating_) {
                ESP_LOGD(TAG, "Currently updating");
                return upload_end_(false);
              }

              if (!network::is_connected()) {
                ESP_LOGD(TAG, "Network is not connected");
                return upload_end_(false);
              }

              if (!disp1->is_setup()) {
                ESP_LOGD(TAG, "Setting Nextion protocol reparse mode to passive");
                exit_reparse_v414->execute();
                delay_seconds_(5);
              }

              is_updating_ = true;

              HTTPClient http;
              http.setTimeout(15000); // Yes 15 seconds.... Helps 8266s along
              http.setFollowRedirects(HTTPC_STRICT_FOLLOW_REDIRECTS);
              bool begin_status = http.begin(url.c_str());
              if (!begin_status) {
                is_updating_ = false;
                ESP_LOGD(TAG, "Connection failed");
                ExternalRAMAllocator<uint8_t> allocator(ExternalRAMAllocator<uint8_t>::ALLOW_FAILURE);
                allocator.deallocate(transfer_buffer_, transfer_buffer_size_);
                return upload_end_(false);
              } else {
                ESP_LOGD(TAG, "Connected");
              }

              http.addHeader("Range", "bytes=0-255");
              const char *header_names[] = {"Content-Range"};
              http.collectHeaders(header_names, 1);
              ESP_LOGD(TAG, "Requesting URL: %s", url.c_str());

              http.setReuse(true);
              // attempt up to 5 times. DNS sometimes needs a second attempt or so
              int tries = 1;
              int code = http.GET();
              delay(100);

              while (code != 200 && code != 206 && tries <= 5) {
                ESP_LOGW(TAG, "HTTP Request failed; URL: %s; Error: %s, reattempting (%d/5)", url.c_str(),
                        HTTPClient::errorToString(code).c_str(), tries);

                delay(250);
                code = http.GET();
                ++tries;
              }

              if ((code != 200 && code != 206) || tries > 5) {
                return upload_end_(false);
              }

              String content_range_string = http.header("Content-Range");
              content_range_string.remove(0, 12);
              content_length_ = content_range_string.toInt();
              tft_size_ = content_length_;
              http.end();

              if (content_length_ < 4096) {
                ESP_LOGE(TAG, "Failed to get file size");
                return upload_end_(false);
              }

              ESP_LOGD(TAG, "Updating Nextion");
              // The Nextion will ignore the update command if it is sleeping

              char command[128];
              // Tells the Nextion the content length of the tft file and baud rate it will be sent at
              // Once the Nextion accepts the command it will wait until the file is successfully uploaded
              // If it fails for any reason a power cycle of the display will be needed
              sprintf(command, "whmi-wris %d,%d,1", content_length_, update_baud_rate_);

              ESP_LOGD(TAG, "Clear serial receive buffer: %d", id(tf_uart).available());
              // Clear serial receive buffer
              uint8_t d;
              while (id(tf_uart).available()) {
                id(tf_uart).read_byte(&d);
              };

              send_nextion_command(command);

              if (update_baud_rate_ != id(tf_uart).get_baud_rate()) {
                set_baud_rate_(update_baud_rate_);
                //id(tf_uart).set_baud_rate(update_baud_rate_);
                //id(tf_uart).setup();
                //delay_seconds_(2);
              }

              ESP_LOGD(TAG, "Waiting for upgrade response");
              std::string response;
              recv_ret_string_(response, 5000, true); // This can take some time to return
              // The Nextion display will, if it's ready to accept data, send a 0x05 byte.
              ESP_LOGD(TAG, "Upgrade response is [%s]",
                      format_hex_pretty(reinterpret_cast<const uint8_t *>(response.data()), response.size()).c_str());

              if (response.find(0x05) != std::string::npos) {
                ESP_LOGD(TAG, "Preparation for tft update done");
              } else {
                ESP_LOGD(TAG, "Preparation for tft update failed %d \"%s\"", response[0], response.c_str());
                return upload_end_(false);
              }

              // Nextion wants 4096 bytes at a time. Make chunk_size a multiple of 4096
              uint32_t chunk_size = 8192;
              if (ESP.getFreeHeap() > 81920) { // Ensure some FreeHeap to other things and limit chunk size
                chunk_size = ESP.getFreeHeap() - 65536;
                chunk_size = int(chunk_size / 4096) * 4096;
                chunk_size = chunk_size > ${upload_tft_chunk_size_max} ? ${upload_tft_chunk_size_max} : chunk_size;
              } else if (ESP.getFreeHeap() < 32768) {
                chunk_size = 4096;
              }

              if (transfer_buffer_ == nullptr) {
                ExternalRAMAllocator<uint8_t> allocator(ExternalRAMAllocator<uint8_t>::ALLOW_FAILURE);
                ESP_LOGD(TAG, "Allocating buffer size %d, Heap size is %" PRIu32, chunk_size, ESP.getFreeHeap());
                transfer_buffer_ = allocator.allocate(chunk_size);
                if (transfer_buffer_ == nullptr) { // Attempt a smaller size
                  ESP_LOGD(TAG, "Could not allocate buffer size: %d attempting 4096 instead", chunk_size);
                  chunk_size = 4096;
                  ESP_LOGD(TAG, "Allocating %d buffer", chunk_size);
                  transfer_buffer_ = allocator.allocate(chunk_size);

                  if (!transfer_buffer_)
                    {
                      return upload_end_(false);
                    }
                }

                transfer_buffer_size_ = chunk_size;
              }

              ESP_LOGD(TAG, "Updating tft from \"%s\" with a file size of %d using %zu chunksize, Heap Size %" PRIu32,
                      url.c_str(), content_length_, transfer_buffer_size_, ESP.getFreeHeap());

              int result = 0;
              while (content_length_ > 0) {
                result = upload_by_chunks_arduino(&http, url, result);
                if (result < 0) {
                  ESP_LOGD(TAG, "Error updating Nextion!");
                  return upload_end_(false);
                }
                App.feed_wdt();
                ESP_LOGD(TAG, "Heap Size %" PRIu32 ", Bytes left %d", ESP.getFreeHeap(), content_length_);
              }
              is_updating_ = false;
              ESP_LOGD(TAG, "Successfully updated Nextion!");

              return upload_end_(true);
            };
          #elif defined(ESP_PLATFORM) // esp-idf # To do: Move to Nextion component on ESPHome
          auto upload_range_esp_idf_ = [&](const std::string &url, int range_start) -> int {
              static const char *const TAG = "addon_upload_tft.script.upload_tft.upload_range_esp_idf_";
              ESP_LOGVV(TAG, "url: %s", url.c_str());
              uint32_t range_size_ = tft_size_ - range_start;
              ESP_LOGVV(TAG, "tft_size_: %i", tft_size_);
              ESP_LOGV(TAG, "Available heap: %" PRIu32, esp_get_free_heap_size());
              int range_end = (range_start == 0) ? std::min(tft_size_, 16383) : tft_size_;
              if (range_size_ <= 0 or range_end <= range_start) {
                ESP_LOGE(TAG, "Invalid range");
                ESP_LOGD(TAG, "Range start: %i", range_start);
                ESP_LOGD(TAG, "Range end: %i", range_end);
                ESP_LOGD(TAG, "Range size: %" PRIu32, range_size_);
                return -1;
              }

              esp_http_client_config_t config = {
                  .url = url.c_str(),
                  .cert_pem = nullptr,
              };
              esp_http_client_handle_t client = esp_http_client_init(&config);

              char range_header[64];
              sprintf(range_header, "bytes=%d-%d", range_start, range_end);
              ESP_LOGV(TAG, "Requesting range: %s", range_header);
              esp_http_client_set_header(client, "Range", range_header);
              ESP_LOGVV(TAG, "Available heap: %u", esp_get_free_heap_size());
              ESP_LOGV(TAG, "Opening http connetion");
              esp_err_t err;
              if ((err = esp_http_client_open(client, 0)) != ESP_OK) {
                  ESP_LOGE(TAG, "Failed to open HTTP connection: %s", esp_err_to_name(err));
                  esp_http_client_cleanup(client);
                  return -1;
              }

              ESP_LOGV(TAG, "Fetch content length");
              int content_length = esp_http_client_fetch_headers(client);
              ESP_LOGV(TAG, "content_length = %d", content_length);
              if (content_length <= 0) {
                ESP_LOGE(TAG, "Failed to get content length: %d", content_length);
                esp_http_client_cleanup(client);
                return -1;
              }

              int total_read_len = 0, read_len;

              ESP_LOGV(TAG, "Allocate buffer");
              uint8_t* buffer = new uint8_t[4096];
              std::string recv_string;
              if (buffer == nullptr) {
                ESP_LOGE(TAG, "Failed to allocate memory for buffer");
                ESP_LOGV(TAG, "Available heap: %" PRIu32, esp_get_free_heap_size());
              } else {
                ESP_LOGV(TAG, "Memory for buffer allocated successfully");

                while (true) {
                  App.feed_wdt();
                  ESP_LOGVV(TAG, "Available heap: %u", esp_get_free_heap_size());
                  int read_len = esp_http_client_read(client, reinterpret_cast<char*>(buffer), 4096);
                  ESP_LOGVV(TAG, "Read %d bytes from HTTP client, writing to UART", read_len);
                  if (read_len > 0) {
                    tf_uart->write_array(buffer, read_len);
                    ESP_LOGVV(TAG, "Write to UART successful");
                    recv_ret_string_(recv_string, 5000, true);
                    content_length_ -= read_len;
                    ESP_LOGD(TAG, "Uploaded %0.2f %%, remaining %d bytes",
                            100.0 * (tft_size_ - content_length_) / tft_size_,
                            content_length_);
                    if (recv_string[0] != 0x05) {  // 0x05 == "ok"
                      ESP_LOGD(TAG, "recv_string [%s]",
                              format_hex_pretty(reinterpret_cast<const uint8_t *>(recv_string.data()), recv_string.size()).c_str());
                    }
                    // handle partial upload request
                    if (recv_string[0] == 0x08 && recv_string.size() == 5) {
                      uint32_t result = 0;
                      for (int j = 0; j < 4; ++j) {
                        result += static_cast<uint8_t>(recv_string[j + 1]) << (8 * j);
                      }
                      if (result > 0) {
                        ESP_LOGI(TAG, "Nextion reported new range %" PRIu32, result);
                        content_length_ = tft_size_ - result;
                        // Deallocate the buffer when done
                        delete[] buffer;
                        ESP_LOGVV(TAG, "Memory for buffer deallocated");
                        esp_http_client_cleanup(client);
                        esp_http_client_close(client);
                        return result;
                      }
                    }
                    recv_string.clear();
                  } else if (read_len == 0) {
                    ESP_LOGV(TAG, "End of HTTP response reached");
                    break;  // Exit the loop if there is no more data to read
                  } else {
                    ESP_LOGE(TAG, "Failed to read from HTTP client, error code: %d", read_len);
                    break;  // Exit the loop on error
                  }
                }

                // Deallocate the buffer when done
                delete[] buffer;
                ESP_LOGVV(TAG, "Memory for buffer deallocated");
              }
              esp_http_client_cleanup(client);
              esp_http_client_close(client);
              return range_end + 1;
            };
          auto upload_tft_ = [&](const std::string &url, unsigned int update_baud_rate_) -> bool {
              static const char *const TAG = "addon_upload_tft.script.upload_tft.upload_tft_esp_idf";
              ESP_LOGD(TAG, "Nextion TFT upload requested");
              ESP_LOGD(TAG, "  url: %s", url.c_str());
              ESP_LOGD(TAG, "  baud_rate: %u", update_baud_rate_);

              if (is_updating_) {
                ESP_LOGW(TAG, "Currently updating");
                return upload_end_(false);
              }

              if (!network::is_connected()) {
                ESP_LOGE(TAG, "Network is not connected");
                return upload_end_(false);
              }

              if (!disp1->is_setup()) {
                ESP_LOGD(TAG, "Setting Nextion protocol reparse mode to passive");
                exit_reparse_v414->execute();
                delay_seconds_(5);
              }

              is_updating_ = true;

              // Define the configuration for the HTTP client
              ESP_LOGV(TAG, "Establishing connection to HTTP server");
              ESP_LOGVV(TAG, "Available heap: %u", esp_get_free_heap_size());
              esp_http_client_config_t config = {
                  .url = url.c_str(),
                  .cert_pem = nullptr,
                  .method = HTTP_METHOD_HEAD,
                  .timeout_ms = 15000,
              };

              // Initialize the HTTP client with the configuration
              ESP_LOGV(TAG, "Initializing HTTP client");
              ESP_LOGV(TAG, "Available heap: %" PRIu32, esp_get_free_heap_size());
              esp_http_client_handle_t http = esp_http_client_init(&config);
              if (!http) {
                  ESP_LOGE(TAG, "Failed to initialize HTTP client.");
                  return upload_end_(false);  // return -1 to indicate an error
              }

              // Perform the HTTP request
              ESP_LOGV(TAG, "Check if the client could connect");
              ESP_LOGV(TAG, "Available heap: %" PRIu32, esp_get_free_heap_size());
              esp_err_t err = esp_http_client_perform(http);
              if (err != ESP_OK) {
                  ESP_LOGE(TAG, "HTTP request failed: %s", esp_err_to_name(err));
                  esp_http_client_cleanup(http);
                  return upload_end_(false);
              }

              // Check the HTTP Status Code
              int status_code = esp_http_client_get_status_code(http);
              ESP_LOGV(TAG, "HTTP Status Code: %d", status_code);
              size_t tft_file_size = esp_http_client_get_content_length(http);
              ESP_LOGD(TAG, "TFT file size: %zu", tft_file_size);

              if (tft_file_size < 4096) {
                  ESP_LOGE(TAG, "File size check failed. Size: %zu", tft_file_size);
                  esp_http_client_cleanup(http);
                  return upload_end_(false);
              } else {
                  ESP_LOGD(TAG, "File size check passed. Proceeding...");
              }
              content_length_ = tft_file_size;
              tft_size_ = tft_file_size;

              ESP_LOGD(TAG, "Updating Nextion");
              // The Nextion will ignore the update command if it is sleeping

              char command[128];
              // Tells the Nextion the content length of the tft file and baud rate it will be sent at
              // Once the Nextion accepts the command it will wait until the file is successfully uploaded
              // If it fails for any reason a power cycle of the display will be needed
              sprintf(command, "whmi-wris %d,%d,1", content_length_, update_baud_rate_);

              // Clear serial receive buffer
              uint8_t d;
              while (id(tf_uart).available()) {
                id(tf_uart).read_byte(&d);
              };

              send_nextion_command(command);

              if (update_baud_rate_ != id(tf_uart).get_baud_rate()) {
                set_baud_rate_(update_baud_rate_);
                //id(tf_uart).set_baud_rate(update_baud_rate_);
                //id(tf_uart).setup();
              }

              std::string response;
              ESP_LOGD(TAG, "Waiting for upgrade response");
              recv_ret_string_(response, 2000, true); // This can take some time to return

              // The Nextion display will, if it's ready to accept data, send a 0x05 byte.
              ESP_LOGD(TAG, "Upgrade response is [%s]",
                      format_hex_pretty(reinterpret_cast<const uint8_t *>(response.data()), response.size()).c_str());

              if (response.find(0x05) != std::string::npos) {
                ESP_LOGV(TAG, "Preparation for tft update done");
              } else {
                ESP_LOGE(TAG, "Preparation for tft update failed %d \"%s\"", response[0], response.c_str());
                esp_http_client_cleanup(http);
                return upload_end_(false);
              }

              ESP_LOGD(TAG, "Updating tft from \"%s\" with a file size of %d, Heap Size %" PRIu32,
                      url.c_str(), content_length_, esp_get_free_heap_size());

              ESP_LOGV(TAG, "Starting transfer by chunks loop");
              int result = 0;
              while (content_length_ > 0) {
                  result = upload_range_esp_idf_(url.c_str(), result);
                  if (result < 0) {
                      ESP_LOGE(TAG, "Error updating Nextion!");
                      esp_http_client_cleanup(http);
                      return upload_end_(false);
                  }
                  App.feed_wdt();
                  ESP_LOGV(TAG, "Heap Size %" PRIu32 ", Bytes left %d", esp_get_free_heap_size(), content_length_);
              }

              is_updating_ = false;
              ESP_LOGD(TAG, "Successfully updated Nextion!");

              ESP_LOGD(TAG, "Close HTTP connection");
              esp_http_client_close(http);
              esp_http_client_cleanup(http);
              return upload_end_(true);
            };
          #endif

          if (upload_tft_(url, 115200)) App.safe_reboot();
          char update_msg[128];
          sprintf(update_msg, "Attempt #%d at %" PRIu32 " bps failed!", id(tft_upload_attempt), tf_uart->get_baud_rate());
          report_upload_progress->execute(update_msg);
          ESP_LOGD(TAG, "Finished!");
      - script.wait: report_upload_progress

  - id: upload_tft_attempt
    mode: single
    then:
      - logger.log: "Attempting to upload TFT"
      - lambda: !lambda id(tft_upload_attempt)++;
      - lambda: |-
          char update_msg[128];
          sprintf(update_msg, "Attempt #%d at %" PRIu32 " bps", id(tft_upload_attempt), tf_uart->get_baud_rate());
          report_upload_progress->execute(update_msg);
      - script.wait: report_upload_progress
      - wait_until:
          condition:
            - lambda: !lambda return (!id(tft_is_valid));
          timeout: 1s
      - script.execute: nextion_upload
      - script.wait: nextion_upload
      - lambda: |-
          char update_msg[128];
          sprintf(update_msg, "Attempt #%d at %" PRIu32 " bps failed!", id(tft_upload_attempt), tf_uart->get_baud_rate());
          report_upload_progress->execute(update_msg);
      - script.wait: report_upload_progress

select:
  - id: tft_file_branch
    name: ${name} Update TFT display - Branch
    platform: template
    options:
      - "main"
      - "beta"
      - "dev"
    initial_option: "main"
    optimistic: true
    restore_value: true
    internal: true
    entity_category: config
    disabled_by_default: true
    icon: mdi:file-sync
    set_action:
      - script.execute: set_tft_file

  - id: tft_file_model
    name: ${name} Update TFT display - Model
    platform: template
    options:
      - "Use nextion_update_url"
      - "NSPanel Blank"
      - "NSPanel EU"
      - "NSPanel US"
      - "NSPanel US Landscape"
      - "NSPanel EU (CJK languages)"
      - "NSPanel US (CJK languages)"
      - "NSPanel US Landscape (CJK languages)"
    initial_option: "Use nextion_update_url"
    optimistic: true
    restore_value: true
    internal: true
    entity_category: config
    disabled_by_default: false
    icon: mdi:file-sync
    set_action:
      - script.execute: set_tft_file

sensor:
  - id: !extend display_mode
    on_value:
      then:
        lambda: |-
          static const char *const TAG = "addon_upload_tft.sensor.display_mode";
          id(tft_is_valid) = (display_mode->state > 0 and display_mode->state < 4);
          if (id(tft_is_valid))
            ESP_LOGD(TAG, "Valid TFT: True");
          else {
            ESP_LOGW(TAG, "Display mode: %i", int(display_mode->state));
            ESP_LOGW(TAG, "Valid TFT:    False");
          }
...
